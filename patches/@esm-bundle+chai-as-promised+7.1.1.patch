diff --git a/node_modules/@esm-bundle/chai-as-promised/index.js b/node_modules/@esm-bundle/chai-as-promised/index.js
new file mode 100644
index 0000000..f327f74
--- /dev/null
+++ b/node_modules/@esm-bundle/chai-as-promised/index.js
@@ -0,0 +1,2 @@
+var t={exports:{}};var e=/\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\(\/]+)/;function r(t){var r="";if(void 0===t.name){var n=String(t).match(e);n&&(r=n[1])}else r=t.name;return r}var n={compatibleInstance:function(t,e){return e instanceof Error&&t===e},compatibleConstructor:function(t,e){return e instanceof Error?t.constructor===e.constructor||t instanceof e.constructor:(e.prototype instanceof Error||e===Error)&&(t.constructor===e||t instanceof e)},compatibleMessage:function(t,e){var r="string"==typeof t?t:t.message;return e instanceof RegExp?e.test(r):"string"==typeof e&&-1!==r.indexOf(e)},getMessage:function(t){var e="";return t&&t.message?e=t.message:"string"==typeof t&&(e=t),e},getConstructorName:function(t){var e=t;return t instanceof Error?e=r(t.constructor):"function"==typeof t&&(e=r(t).trim()||r(new t)),e}};!function(t){let e=n;t.exports=(r,n)=>{const o=r.Assertion,i=r.assert,s=n.proxify;function c(t){if("function"!=typeof t._obj.then)throw new TypeError(n.inspect(t._obj)+" is not a thenable.");if("function"!=typeof(e=t._obj).catch&&"function"==typeof e.always&&"function"==typeof e.done&&"function"==typeof e.fail&&"function"==typeof e.pipe&&"function"==typeof e.progress&&"function"==typeof e.state)throw new TypeError("Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please upgrade jQuery or use another Promises/A+ compatible library (see http://promisesaplus.com/).");var e}function a(t){return void 0===s?t:s(t)}function u(t,e){n.addMethod(o.prototype,t,(function(){return c(this),e.apply(this,arguments)}))}function f(t,e){n.addProperty(o.prototype,t,(function(){return c(this),a(e.apply(this,arguments))}))}function p(t,e){t.then((()=>e()),e)}function l(t,e,r){t.assert(!0,null,e,r.expected,r.actual)}function h(t,e,r){t.assert(!1,e,null,r.expected,r.actual)}function d(t){return"function"==typeof t.then?t:t._obj}function y(t){return t instanceof Error?t.toString():e.getConstructorName(t)}n.checkError&&(e=n.checkError);const b=Object.getOwnPropertyNames(o.prototype),m={};for(const t of b)m[t]=Object.getOwnPropertyDescriptor(o.prototype,t);f("fulfilled",(function(){const e=d(this).then((t=>(l(this,"expected promise not to be fulfilled but it was fulfilled with #{act}",{actual:t}),t)),(t=>(h(this,"expected promise to be fulfilled but it was rejected with #{act}",{actual:y(t)}),t)));return t.exports.transferPromiseness(this,e),this})),f("rejected",(function(){const e=d(this).then((t=>(h(this,"expected promise to be rejected but it was fulfilled with #{act}",{actual:t}),t)),(t=>(l(this,"expected promise not to be rejected but it was rejected with #{act}",{actual:y(t)}),t)));return t.exports.transferPromiseness(this,e),this})),u("rejectedWith",(function(r,o,i){let s=null;const c=n.flag(this,"negate")||!1;if(void 0===r&&void 0===o&&void 0===i)return this.rejected;void 0!==i&&n.flag(this,"message",i),r instanceof RegExp||"string"==typeof r?(o=r,r=null):r&&r instanceof Error?s=r.toString():"function"==typeof r?s=e.getConstructorName(r):r=null;const a=Boolean(r&&o);let u="including";o instanceof RegExp&&(u="matching");const f=d(this).then((t=>{let e=null,n=null;return r?(e="expected promise to be rejected with #{exp} but it was fulfilled with #{act}",n=s):o&&(e=`expected promise to be rejected with an error ${u} #{exp} but it was fulfilled with #{act}`,n=o),h(this,e,{expected:n,actual:t}),t}),(t=>{const n=r&&(r instanceof Error?e.compatibleInstance(t,r):e.compatibleConstructor(t,r)),i=o&&e.compatibleMessage(t,o),f=y(t);return c&&a?n&&i&&this.assert(!0,null,"expected promise not to be rejected with #{exp} but it was rejected with #{act}",s,f):(r&&this.assert(n,"expected promise to be rejected with #{exp} but it was rejected with #{act}","expected promise not to be rejected with #{exp} but it was rejected with #{act}",s,f),o&&this.assert(i,`expected promise to be rejected with an error ${u} #{exp} but got #{act}`,`expected promise not to be rejected with an error ${u} #{exp}`,o,e.getMessage(t))),t}));return t.exports.transferPromiseness(this,f),this})),f("eventually",(function(){return n.flag(this,"eventually",!0),this})),u("notify",(function(t){return p(d(this),t),this})),u("become",(function(t,e){return this.eventually.deep.equal(t,e)}));b.filter((t=>"assert"!==t&&"function"==typeof m[t].value)).forEach((t=>{o.overwriteMethod(t,(t=>function(){return g(t,this,arguments)}))}));function g(e,r,o){if(!n.flag(r,"eventually"))return e.apply(r,o),r;const i=d(r).then((e=>(r._obj=e,n.flag(r,"eventually",!1),o?t.exports.transformAsserterArgs(o):o))).then((t=>(e.apply(r,t),r._obj)));return t.exports.transferPromiseness(r,i),r}b.filter((t=>"_obj"!==t&&"function"==typeof m[t].get)).forEach((t=>{o.prototype.__methods.hasOwnProperty(t)?o.overwriteChainableMethod(t,(t=>function(){return g(t,this,arguments)}),(t=>function(){return g(t,this)})):o.overwriteProperty(t,(t=>function(){return a(g(t,this))}))}));const w=Object.getOwnPropertyNames(i).filter((t=>"function"==typeof i[t]));i.isFulfilled=(t,e)=>new o(t,e).to.be.fulfilled,i.isRejected=(t,e,r,n)=>new o(t,n).to.be.rejectedWith(e,r,n),i.becomes=(t,e,r)=>i.eventually.deepEqual(t,e,r),i.doesNotBecome=(t,e,r)=>i.eventually.notDeepEqual(t,e,r),i.eventually={},w.forEach((t=>{i.eventually[t]=function(e){const o=Array.prototype.slice.call(arguments,1);let s;const c=arguments[i[t].length-1];"string"==typeof c&&(s=t=>{throw new r.AssertionError(`${c}\n\nOriginal reason: ${n.inspect(t)}`)});const a=e.then((e=>i[t].apply(i,[e].concat(o))),s);return a.notify=t=>{p(a,t)},a}}))},t.exports.transferPromiseness=(t,e)=>{t.then=e.then.bind(e)},t.exports.transformAsserterArgs=t=>t}(t);var o=t.exports;export{o as default};
+//# sourceMappingURL=index.js.map
diff --git a/node_modules/@esm-bundle/chai-as-promised/index.js.map b/node_modules/@esm-bundle/chai-as-promised/index.js.map
new file mode 100644
index 0000000..172dee6
--- /dev/null
+++ b/node_modules/@esm-bundle/chai-as-promised/index.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.js","sources":["../node_modules/.pnpm/check-error@1.0.2/node_modules/check-error/index.js","../node_modules/.pnpm/chai-as-promised@7.1.1_chai@4.3.4/node_modules/chai-as-promised/lib/chai-as-promised.js"],"sourcesContent":["'use strict';\n\n/* !\n * Chai - checkError utility\n * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .checkError\n *\n * Checks that an error conforms to a given set of criteria and/or retrieves information about it.\n *\n * @api public\n */\n\n/**\n * ### .compatibleInstance(thrown, errorLike)\n *\n * Checks if two instances are compatible (strict equal).\n * Returns false if errorLike is not an instance of Error, because instances\n * can only be compatible if they're both error instances.\n *\n * @name compatibleInstance\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleInstance(thrown, errorLike) {\n  return errorLike instanceof Error && thrown === errorLike;\n}\n\n/**\n * ### .compatibleConstructor(thrown, errorLike)\n *\n * Checks if two constructors are compatible.\n * This function can receive either an error constructor or\n * an error instance as the `errorLike` argument.\n * Constructors are compatible if they're the same or if one is\n * an instance of another.\n *\n * @name compatibleConstructor\n * @param {Error} thrown error\n * @param {Error|ErrorConstructor} errorLike object to compare against\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleConstructor(thrown, errorLike) {\n  if (errorLike instanceof Error) {\n    // If `errorLike` is an instance of any error we compare their constructors\n    return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;\n  } else if (errorLike.prototype instanceof Error || errorLike === Error) {\n    // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly\n    return thrown.constructor === errorLike || thrown instanceof errorLike;\n  }\n\n  return false;\n}\n\n/**\n * ### .compatibleMessage(thrown, errMatcher)\n *\n * Checks if an error's message is compatible with a matcher (String or RegExp).\n * If the message contains the String or passes the RegExp test,\n * it is considered compatible.\n *\n * @name compatibleMessage\n * @param {Error} thrown error\n * @param {String|RegExp} errMatcher to look for into the message\n * @namespace Utils\n * @api public\n */\n\nfunction compatibleMessage(thrown, errMatcher) {\n  var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;\n  if (errMatcher instanceof RegExp) {\n    return errMatcher.test(comparisonString);\n  } else if (typeof errMatcher === 'string') {\n    return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers\n  }\n\n  return false;\n}\n\n/**\n * ### .getFunctionName(constructorFn)\n *\n * Returns the name of a function.\n * This also includes a polyfill function if `constructorFn.name` is not defined.\n *\n * @name getFunctionName\n * @param {Function} constructorFn\n * @namespace Utils\n * @api private\n */\n\nvar functionNameMatch = /\\s*function(?:\\s|\\s*\\/\\*[^(?:*\\/)]+\\*\\/\\s*)*([^\\(\\/]+)/;\nfunction getFunctionName(constructorFn) {\n  var name = '';\n  if (typeof constructorFn.name === 'undefined') {\n    // Here we run a polyfill if constructorFn.name is not defined\n    var match = String(constructorFn).match(functionNameMatch);\n    if (match) {\n      name = match[1];\n    }\n  } else {\n    name = constructorFn.name;\n  }\n\n  return name;\n}\n\n/**\n * ### .getConstructorName(errorLike)\n *\n * Gets the constructor name for an Error instance or constructor itself.\n *\n * @name getConstructorName\n * @param {Error|ErrorConstructor} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getConstructorName(errorLike) {\n  var constructorName = errorLike;\n  if (errorLike instanceof Error) {\n    constructorName = getFunctionName(errorLike.constructor);\n  } else if (typeof errorLike === 'function') {\n    // If `err` is not an instance of Error it is an error constructor itself or another function.\n    // If we've got a common function we get its name, otherwise we may need to create a new instance\n    // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.\n    constructorName = getFunctionName(errorLike).trim() ||\n        getFunctionName(new errorLike()); // eslint-disable-line new-cap\n  }\n\n  return constructorName;\n}\n\n/**\n * ### .getMessage(errorLike)\n *\n * Gets the error message from an error.\n * If `err` is a String itself, we return it.\n * If the error has no message, we return an empty string.\n *\n * @name getMessage\n * @param {Error|String} errorLike\n * @namespace Utils\n * @api public\n */\n\nfunction getMessage(errorLike) {\n  var msg = '';\n  if (errorLike && errorLike.message) {\n    msg = errorLike.message;\n  } else if (typeof errorLike === 'string') {\n    msg = errorLike;\n  }\n\n  return msg;\n}\n\nmodule.exports = {\n  compatibleInstance: compatibleInstance,\n  compatibleConstructor: compatibleConstructor,\n  compatibleMessage: compatibleMessage,\n  getMessage: getMessage,\n  getConstructorName: getConstructorName,\n};\n","\"use strict\";\n/* eslint-disable no-invalid-this */\nlet checkError = require(\"check-error\");\n\nmodule.exports = (chai, utils) => {\n    const Assertion = chai.Assertion;\n    const assert = chai.assert;\n    const proxify = utils.proxify;\n\n    // If we are using a version of Chai that has checkError on it,\n    // we want to use that version to be consistent. Otherwise, we use\n    // what was passed to the factory.\n    if (utils.checkError) {\n        checkError = utils.checkError;\n    }\n\n    function isLegacyJQueryPromise(thenable) {\n        // jQuery promises are Promises/A+-compatible since 3.0.0. jQuery 3.0.0 is also the first version\n        // to define the catch method.\n        return typeof thenable.catch !== \"function\" &&\n               typeof thenable.always === \"function\" &&\n               typeof thenable.done === \"function\" &&\n               typeof thenable.fail === \"function\" &&\n               typeof thenable.pipe === \"function\" &&\n               typeof thenable.progress === \"function\" &&\n               typeof thenable.state === \"function\";\n    }\n\n    function assertIsAboutPromise(assertion) {\n        if (typeof assertion._obj.then !== \"function\") {\n            throw new TypeError(utils.inspect(assertion._obj) + \" is not a thenable.\");\n        }\n        if (isLegacyJQueryPromise(assertion._obj)) {\n            throw new TypeError(\"Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please \" +\n                                \"upgrade jQuery or use another Promises/A+ compatible library (see \" +\n                                \"http://promisesaplus.com/).\");\n        }\n    }\n\n    function proxifyIfSupported(assertion) {\n        return proxify === undefined ? assertion : proxify(assertion);\n    }\n\n    function method(name, asserter) {\n        utils.addMethod(Assertion.prototype, name, function () {\n            assertIsAboutPromise(this);\n            return asserter.apply(this, arguments);\n        });\n    }\n\n    function property(name, asserter) {\n        utils.addProperty(Assertion.prototype, name, function () {\n            assertIsAboutPromise(this);\n            return proxifyIfSupported(asserter.apply(this, arguments));\n        });\n    }\n\n    function doNotify(promise, done) {\n        promise.then(() => done(), done);\n    }\n\n    // These are for clarity and to bypass Chai refusing to allow `undefined` as actual when used with `assert`.\n    function assertIfNegated(assertion, message, extra) {\n        assertion.assert(true, null, message, extra.expected, extra.actual);\n    }\n\n    function assertIfNotNegated(assertion, message, extra) {\n        assertion.assert(false, message, null, extra.expected, extra.actual);\n    }\n\n    function getBasePromise(assertion) {\n        // We need to chain subsequent asserters on top of ones in the chain already (consider\n        // `eventually.have.property(\"foo\").that.equals(\"bar\")`), only running them after the existing ones pass.\n        // So the first base-promise is `assertion._obj`, but after that we use the assertions themselves, i.e.\n        // previously derived promises, to chain off of.\n        return typeof assertion.then === \"function\" ? assertion : assertion._obj;\n    }\n\n    function getReasonName(reason) {\n        return reason instanceof Error ? reason.toString() : checkError.getConstructorName(reason);\n    }\n\n    // Grab these first, before we modify `Assertion.prototype`.\n\n    const propertyNames = Object.getOwnPropertyNames(Assertion.prototype);\n\n    const propertyDescs = {};\n    for (const name of propertyNames) {\n        propertyDescs[name] = Object.getOwnPropertyDescriptor(Assertion.prototype, name);\n    }\n\n    property(\"fulfilled\", function () {\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                assertIfNegated(this,\n                                \"expected promise not to be fulfilled but it was fulfilled with #{act}\",\n                                { actual: value });\n                return value;\n            },\n            reason => {\n                assertIfNotNegated(this,\n                                   \"expected promise to be fulfilled but it was rejected with #{act}\",\n                                   { actual: getReasonName(reason) });\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    property(\"rejected\", function () {\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                assertIfNotNegated(this,\n                                   \"expected promise to be rejected but it was fulfilled with #{act}\",\n                                   { actual: value });\n                return value;\n            },\n            reason => {\n                assertIfNegated(this,\n                                \"expected promise not to be rejected but it was rejected with #{act}\",\n                                { actual: getReasonName(reason) });\n\n                // Return the reason, transforming this into a fulfillment, to allow further assertions, e.g.\n                // `promise.should.be.rejected.and.eventually.equal(\"reason\")`.\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    method(\"rejectedWith\", function (errorLike, errMsgMatcher, message) {\n        let errorLikeName = null;\n        const negate = utils.flag(this, \"negate\") || false;\n\n        // rejectedWith with that is called without arguments is\n        // the same as a plain \".rejected\" use.\n        if (errorLike === undefined && errMsgMatcher === undefined &&\n            message === undefined) {\n            /* eslint-disable no-unused-expressions */\n            return this.rejected;\n            /* eslint-enable no-unused-expressions */\n        }\n\n        if (message !== undefined) {\n            utils.flag(this, \"message\", message);\n        }\n\n        if (errorLike instanceof RegExp || typeof errorLike === \"string\") {\n            errMsgMatcher = errorLike;\n            errorLike = null;\n        } else if (errorLike && errorLike instanceof Error) {\n            errorLikeName = errorLike.toString();\n        } else if (typeof errorLike === \"function\") {\n            errorLikeName = checkError.getConstructorName(errorLike);\n        } else {\n            errorLike = null;\n        }\n        const everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n\n        let matcherRelation = \"including\";\n        if (errMsgMatcher instanceof RegExp) {\n            matcherRelation = \"matching\";\n        }\n\n        const derivedPromise = getBasePromise(this).then(\n            value => {\n                let assertionMessage = null;\n                let expected = null;\n\n                if (errorLike) {\n                    assertionMessage = \"expected promise to be rejected with #{exp} but it was fulfilled with #{act}\";\n                    expected = errorLikeName;\n                } else if (errMsgMatcher) {\n                    assertionMessage = `expected promise to be rejected with an error ${matcherRelation} #{exp} but ` +\n                                       `it was fulfilled with #{act}`;\n                    expected = errMsgMatcher;\n                }\n\n                assertIfNotNegated(this, assertionMessage, { expected, actual: value });\n                return value;\n            },\n            reason => {\n                const errorLikeCompatible = errorLike && (errorLike instanceof Error ?\n                                                        checkError.compatibleInstance(reason, errorLike) :\n                                                        checkError.compatibleConstructor(reason, errorLike));\n\n                const errMsgMatcherCompatible = errMsgMatcher && checkError.compatibleMessage(reason, errMsgMatcher);\n\n                const reasonName = getReasonName(reason);\n\n                if (negate && everyArgIsDefined) {\n                    if (errorLikeCompatible && errMsgMatcherCompatible) {\n                        this.assert(true,\n                                    null,\n                                    \"expected promise not to be rejected with #{exp} but it was rejected \" +\n                                    \"with #{act}\",\n                                    errorLikeName,\n                                    reasonName);\n                    }\n                } else {\n                    if (errorLike) {\n                        this.assert(errorLikeCompatible,\n                                    \"expected promise to be rejected with #{exp} but it was rejected with #{act}\",\n                                    \"expected promise not to be rejected with #{exp} but it was rejected \" +\n                                    \"with #{act}\",\n                                    errorLikeName,\n                                    reasonName);\n                    }\n\n                    if (errMsgMatcher) {\n                        this.assert(errMsgMatcherCompatible,\n                                    `expected promise to be rejected with an error ${matcherRelation} #{exp} but got ` +\n                                    `#{act}`,\n                                    `expected promise not to be rejected with an error ${matcherRelation} #{exp}`,\n                                    errMsgMatcher,\n                                    checkError.getMessage(reason));\n                    }\n                }\n\n                return reason;\n            }\n        );\n\n        module.exports.transferPromiseness(this, derivedPromise);\n        return this;\n    });\n\n    property(\"eventually\", function () {\n        utils.flag(this, \"eventually\", true);\n        return this;\n    });\n\n    method(\"notify\", function (done) {\n        doNotify(getBasePromise(this), done);\n        return this;\n    });\n\n    method(\"become\", function (value, message) {\n        return this.eventually.deep.equal(value, message);\n    });\n\n    // ### `eventually`\n\n    // We need to be careful not to trigger any getters, thus `Object.getOwnPropertyDescriptor` usage.\n    const methodNames = propertyNames.filter(name => {\n        return name !== \"assert\" && typeof propertyDescs[name].value === \"function\";\n    });\n\n    methodNames.forEach(methodName => {\n        Assertion.overwriteMethod(methodName, originalMethod => function () {\n            return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n        });\n    });\n\n    const getterNames = propertyNames.filter(name => {\n        return name !== \"_obj\" && typeof propertyDescs[name].get === \"function\";\n    });\n\n    getterNames.forEach(getterName => {\n        // Chainable methods are things like `an`, which can work both for `.should.be.an.instanceOf` and as\n        // `should.be.an(\"object\")`. We need to handle those specially.\n        const isChainableMethod = Assertion.prototype.__methods.hasOwnProperty(getterName);\n\n        if (isChainableMethod) {\n            Assertion.overwriteChainableMethod(\n                getterName,\n                originalMethod => function () {\n                    return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n                },\n                originalGetter => function () {\n                    return doAsserterAsyncAndAddThen(originalGetter, this);\n                }\n            );\n        } else {\n            Assertion.overwriteProperty(getterName, originalGetter => function () {\n                return proxifyIfSupported(doAsserterAsyncAndAddThen(originalGetter, this));\n            });\n        }\n    });\n\n    function doAsserterAsyncAndAddThen(asserter, assertion, args) {\n        // Since we're intercepting all methods/properties, we need to just pass through if they don't want\n        // `eventually`, or if we've already fulfilled the promise (see below).\n        if (!utils.flag(assertion, \"eventually\")) {\n            asserter.apply(assertion, args);\n            return assertion;\n        }\n\n        const derivedPromise = getBasePromise(assertion).then(value => {\n            // Set up the environment for the asserter to actually run: `_obj` should be the fulfillment value, and\n            // now that we have the value, we're no longer in \"eventually\" mode, so we won't run any of this code,\n            // just the base Chai code that we get to via the short-circuit above.\n            assertion._obj = value;\n            utils.flag(assertion, \"eventually\", false);\n\n            return args ? module.exports.transformAsserterArgs(args) : args;\n        }).then(newArgs => {\n            asserter.apply(assertion, newArgs);\n\n            // Because asserters, for example `property`, can change the value of `_obj` (i.e. change the \"object\"\n            // flag), we need to communicate this value change to subsequent chained asserters. Since we build a\n            // promise chain paralleling the asserter chain, we can use it to communicate such changes.\n            return assertion._obj;\n        });\n\n        module.exports.transferPromiseness(assertion, derivedPromise);\n        return assertion;\n    }\n\n    // ### Now use the `Assertion` framework to build an `assert` interface.\n    const originalAssertMethods = Object.getOwnPropertyNames(assert).filter(propName => {\n        return typeof assert[propName] === \"function\";\n    });\n\n    assert.isFulfilled = (promise, message) => (new Assertion(promise, message)).to.be.fulfilled;\n\n    assert.isRejected = (promise, errorLike, errMsgMatcher, message) => {\n        const assertion = new Assertion(promise, message);\n        return assertion.to.be.rejectedWith(errorLike, errMsgMatcher, message);\n    };\n\n    assert.becomes = (promise, value, message) => assert.eventually.deepEqual(promise, value, message);\n\n    assert.doesNotBecome = (promise, value, message) => assert.eventually.notDeepEqual(promise, value, message);\n\n    assert.eventually = {};\n    originalAssertMethods.forEach(assertMethodName => {\n        assert.eventually[assertMethodName] = function (promise) {\n            const otherArgs = Array.prototype.slice.call(arguments, 1);\n\n            let customRejectionHandler;\n            const message = arguments[assert[assertMethodName].length - 1];\n            if (typeof message === \"string\") {\n                customRejectionHandler = reason => {\n                    throw new chai.AssertionError(`${message}\\n\\nOriginal reason: ${utils.inspect(reason)}`);\n                };\n            }\n\n            const returnedPromise = promise.then(\n                fulfillmentValue => assert[assertMethodName].apply(assert, [fulfillmentValue].concat(otherArgs)),\n                customRejectionHandler\n            );\n\n            returnedPromise.notify = done => {\n                doNotify(returnedPromise, done);\n            };\n\n            return returnedPromise;\n        };\n    });\n};\n\nmodule.exports.transferPromiseness = (assertion, promise) => {\n    assertion.then = promise.then.bind(promise);\n};\n\nmodule.exports.transformAsserterArgs = values => values;\n"],"names":["functionNameMatch","getFunctionName","constructorFn","name","match","String","checkError","compatibleInstance","thrown","errorLike","Error","compatibleConstructor","constructor","prototype","compatibleMessage","errMatcher","comparisonString","message","RegExp","test","indexOf","getMessage","msg","getConstructorName","constructorName","trim","require$$0","module","chai","utils","Assertion","assert","proxify","assertIsAboutPromise","assertion","_obj","then","TypeError","inspect","thenable","catch","always","done","fail","pipe","progress","state","proxifyIfSupported","undefined","method","asserter","addMethod","this","apply","arguments","property","addProperty","doNotify","promise","assertIfNegated","extra","expected","actual","assertIfNotNegated","getBasePromise","getReasonName","reason","toString","propertyNames","Object","getOwnPropertyNames","propertyDescs","getOwnPropertyDescriptor","derivedPromise","value","exports","transferPromiseness","errMsgMatcher","errorLikeName","negate","flag","rejected","everyArgIsDefined","Boolean","matcherRelation","assertionMessage","errorLikeCompatible","errMsgMatcherCompatible","reasonName","eventually","deep","equal","filter","forEach","methodName","overwriteMethod","originalMethod","doAsserterAsyncAndAddThen","args","transformAsserterArgs","newArgs","get","getterName","__methods","hasOwnProperty","overwriteChainableMethod","originalGetter","overwriteProperty","originalAssertMethods","propName","isFulfilled","to","be","fulfilled","isRejected","rejectedWith","becomes","deepEqual","doesNotBecome","notDeepEqual","assertMethodName","otherArgs","Array","slice","call","customRejectionHandler","length","AssertionError","returnedPromise","fulfillmentValue","concat","notify","bind","values"],"mappings":"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"}
\ No newline at end of file
