---
import  { z } from 'astro/zod';
import type { Props } from '@astrojs/starlight/props';
import config from '../../starlight-config';

const HeadConfigSchema = () =>
	z
		.array(
			z.object({
				/** Name of the HTML tag to add to `<head>`, e.g. `'meta'`, `'link'`, or `'script'`. */
				tag: z.enum(['title', 'base', 'link', 'style', 'meta', 'script', 'noscript', 'template']),
				/** Attributes to set on the tag, e.g. `{ rel: 'stylesheet', href: '/custom.css' }`. */
				attrs: z.record(z.union([z.string(), z.boolean(), z.undefined()])).default({}),
				/** Content to place inside the tag (optional). */
				content: z.string().default(''),
			})
		)
		.default([]);

type HeadUserConfig = z.input<ReturnType<typeof HeadConfigSchema>>;
type HeadConfig = z.output<ReturnType<typeof HeadConfigSchema>>;

const HeadSchema = HeadConfigSchema();

const { entry, lang } = Astro.props;
const { data } = entry;

const canonical = Astro.site ? new URL(Astro.url.pathname, Astro.site) : undefined;
const description = data.description || config.description;

const base = stripTrailingSlash(import.meta.env.BASE_URL);

function createHead(defaults: HeadUserConfig, ...heads: HeadConfig[]) {
	let head = HeadSchema.parse(defaults);
	for (const next of heads) {
		head = mergeHead(head, next);
	}
	return sortHead(head);
}

/**
 * Test if a head config object contains a matching `<title>` or `<meta>` tag.
 *
 * For example, will return true if `head` already contains
 * `<meta name="description" content="A">` and the passed `tag`
 * is `<meta name="description" content="B">`. Tests against `name`,
 * `property`, and `http-equiv` attributes for `<meta>` tags.
 */
function hasTag(head: HeadConfig, entry: HeadConfig[number]): boolean {
	switch (entry.tag) {
		case 'title':
			return head.some(({ tag }) => tag === 'title');
		case 'meta':
			return hasOneOf(head, entry, ['name', 'property', 'http-equiv']);
		default:
			return false;
	}
}

/**
 * Test if a head config object contains a tag of the same type
 * as `entry` and a matching attribute for one of the passed `keys`.
 */
function hasOneOf(head: HeadConfig, entry: HeadConfig[number], keys: string[]): boolean {
	const attr = getAttr(keys, entry);
	if (!attr) return false;
	const [key, val] = attr;
	return head.some(({ tag, attrs }) => tag === entry.tag && attrs[key] === val);
}

/** Find the first matching key–value pair in a head entry’s attributes. */
function getAttr(
	keys: string[],
	entry: HeadConfig[number]
): [key: string, value: string | boolean] | undefined {
	let attr: [string, string | boolean] | undefined;
	for (const key of keys) {
		const val = entry.attrs[key];
		if (val) {
			attr = [key, val];
			break;
		}
	}
	return attr;
}

/** Merge two heads, overwriting entries in the first head that exist in the second. */
function mergeHead(oldHead: HeadConfig, newHead: HeadConfig) {
	return [...oldHead.filter((tag) => !hasTag(newHead, tag)), ...newHead];
}

/** Sort head tags to place important tags first and relegate “SEO” meta tags. */
function sortHead(head: HeadConfig) {
	return head.sort((a, b) => {
		const aImportance = getImportance(a);
		const bImportance = getImportance(b);
		return aImportance > bImportance ? -1 : bImportance > aImportance ? 1 : 0;
	});
}

/** Get the relative importance of a specific head tag. */
function getImportance(entry: HeadConfig[number]) {
	// 1. Important meta tags.
	if (
		entry.tag === 'meta' &&
		('charset' in entry.attrs || 'http-equiv' in entry.attrs || entry.attrs.name === 'viewport')
	) {
		return 100;
	}
	// 2. Page title
	if (entry.tag === 'title') return 90;
	// 3. Anything that isn’t an SEO meta tag.
	if (entry.tag !== 'meta') {
		// The default favicon should be below any extra icons that the user may have set
		// because if several icons are equally appropriate, the last one is used and we
		// want to use the SVG icon when supported.
		if (entry.tag === 'link' && 'rel' in entry.attrs && entry.attrs.rel === 'shortcut icon') {
			return 70;
		}
		return 80;
	}
	// 4. SEO meta tags.
	return 0;
}


/** Ensure the passed path does not start with a leading slash. */
function stripLeadingSlash(href: string) {
	if (href[0] === '/') href = href.slice(1);
	return href;
}

/** Ensure the passed path does not end with a trailing slash. */
function stripTrailingSlash(href: string) {
	if (href[href.length - 1] === '/') href = href.slice(0, -1);
	return href;
}

/** Get the a root-relative file URL path with the site’s `base` prefixed. */
function fileWithBase(path: string) {
	path = stripLeadingSlash(path);
	return path ? base + '/' + path : base;
}

const headDefaults: z.input<ReturnType<typeof HeadConfigSchema>> = [
	{ tag: 'meta', attrs: { charset: 'utf-8' } },
	{
		tag: 'meta',
		attrs: { name: 'viewport', content: 'width=device-width, initial-scale=1' },
	},
	{ tag: 'title', content: `${data.title} ${config.titleDelimiter} ${config.title}` },
	{ tag: 'link', attrs: { rel: 'canonical', href: canonical?.href } },
	{ tag: 'meta', attrs: { name: 'generator', content: Astro.generator } },
	// OpenGraph Tags
	{ tag: 'meta', attrs: { property: 'og:title', content: data.title } },
	{ tag: 'meta', attrs: { property: 'og:type', content: 'article' } },
	{ tag: 'meta', attrs: { property: 'og:url', content: canonical?.href } },
	{ tag: 'meta', attrs: { property: 'og:locale', content: lang } },
	{ tag: 'meta', attrs: { property: 'og:description', content: description } },
	{ tag: 'meta', attrs: { property: 'og:site_name', content: config.title } },
	// Twitter Tags
	{
		tag: 'meta',
		attrs: { name: 'twitter:card', content: 'summary_large_image' },
	},
	{ tag: 'meta', attrs: { name: 'twitter:title', content: data.title } },
	{ tag: 'meta', attrs: { name: 'twitter:description', content: description } },
];

if (config.favicon) {
  // Favicon
	headDefaults.push({
		tag: 'link',
		attrs: {
			rel: 'icon',
			href: fileWithBase(config.favicon),
		},
	})
}

if (description) {
	headDefaults.push({
		tag: 'meta',
		attrs: { name: 'description', content: description },
	});
}

// Link to sitemap, but only when `site` is set.
if (Astro.site) {
	headDefaults.push({
		tag: 'link',
		attrs: {
			rel: 'sitemap',
			href: fileWithBase('/sitemap-index.xml'),
		},
	});
}

// Link to Twitter account if set in Starlight config.
if (config.social?.twitter) {
	headDefaults.push({
		tag: 'meta',
		attrs: {
			name: 'twitter:site',
			content: new URL(config.social.twitter).pathname,
		},
	});
}

// @ts-expect-error headitem.content is incorrectly typed in starlight as required prop
const head = createHead(headDefaults, config.head ?? [], data.head ?? []);
---
<script src="../load-playground"></script>
{head.map(({ tag: Tag, attrs, content }) => <Tag {...attrs} set:html={content} />)}