<!--
DO NOT EDIT THIS FILE DIRECTLY, THIS FILE IS GENERATED BY JSDOC!
EDIT scripts/handlebars/templates/api.hbs OR JSDOC COMMENT INSTEAD!
-->
# Transforms

Transforms are functions that modify a [token](tokens.md) so that it can be understood by a specific platform. It can modify the name, value, or attributes of a token - enabling each platform to use the design token in different ways. A simple example is changing pixel values to point values for iOS and dp or sp for Android.  

Transforms are isolated per platform; each platform begins with the same design token and makes the modifications it needs without affecting other platforms. The order you use transforms matters because transforms are performed sequentially. Transforms are used in your [configuration](config.md), and can be either [pre-defined transforms](transforms.md?id=pre-defined-transforms) supplied by Style Dictionary or [custom transforms](transforms.md?id=defining-custom-transforms).  

Some platform configuration attributes apply a broader effect over the transforms applied. For example, the `size/remToDp` transform will scale a number by 16, or by the value of `options.basePxFontSize` if it is present. Check individual transform documentation to see where this is applicable.



## Using Transforms
You use transforms in your config file under platforms > [platform] > transforms

```json
{
  "source": ["tokens/**/*.json"],
  "platforms": {
    "android": {
      "transforms": ["attribute/cti", "name/cti/kebab", "color/hex", "size/rem"]
    }
  }
}
```

A transform consists of 4 parts: type, name, matcher, and transformer. Transforms are run on all design tokens where the matcher returns true. *NOTE: if you don't provide a matcher function, it will match all tokens.*

## Transform Types
There are 3 types of transforms: attribute, name, and value.

**Attribute:** An attribute transform adds to the attributes object on a design token. This is for including any meta-data about a design token such as it's CTI or other information.

**Name:** A name transform transform the name of a design token. You should really only be apply one name transformer because they will override each other if you use more than one.

**Value:** The value transform is the most important as this is the one that changes the representation of the value. Colors can be turned into hex values, rgb, hsl, hsv, etc. Value transforms have a matcher function that filter which tokens that transform runs on. This allows us to only run a color transform on only the colors and not every design token.

## Defining Custom Transforms
You can define custom transforms with the [`registerTransform`](api.md#registertransform). Style Dictionary adds some [default metadata](tokens.md?id=default-design-token-metadata) to each design token to provide context that may be useful for some transforms.

## Transitive Transforms
Starting in version 3.0, you can define transitive transforms which allow you to transform a referenced value. Normally, value transforms only transform non-referenced values and because transforms happen before references are resolved, the transformed value is then used to resolve references.

```javascript
const StyleDictionary = require('style-dictionary');

StyleDictionary.registerTransform({
  type: `value`,
  transitive: true,
  name: `myTransitiveTransform`,
  matcher: (token) => {},
  transformer: (token) => {
    // token.value will be resolved and transformed at this point
  }
})
```

There is one thing to be mindful of with transitive transforms. The token's value will be resolved and *transformed* already at the time the transitive transform. What happens is Style Dictionary will transform and resolve values iteratively. First it will transform any non-referenced values, then it will resolve any references to non-referenced values, then it will try to transform any non-referenced values, and so on. Let's take a look at an example:

```json
{
  "color": {
    "red": { "value": "#f00" },
    "danger": { "value": "{color.red}" },
    "error": { "value": "{color.danger}" }
  }
}
```

Style dictionary will first transform the value of `color.red`, then resolve `color.danger` to the transformed `color.red` value. Then it will transform `color.danger` and resolve `color.error` to the transformed `color.danger`. Finally, it will transform `color.error` and see that there is nothing left to transform or resolve.

This allows you to modify a reference that modifies another reference. For example:

```json
{
  "color": {
    "red": { "value": "#f00" },
    "danger": { "value": "{color.red}", "darken": 0.75 },
    "error": { "value": "{color.danger}", "darken": 0.5 }
  }
}
```

Using a custom transitive transform you could have `color.danger` darken `color.red` and `color.error` darken `color.danger`. The pre-defined transforms are *not transitive* to be backwards compatible with Style Dictionary v2 - an upgrade should not cause breaking changes.

If you want to learn more about transitive transforms, take a look at the [transitive transforms example](https://github.com/amzn/style-dictionary/tree/main/examples/advanced/transitive-transforms).


## Pre-defined Transforms

[lib/common/transforms.js](https://github.com/amzn/style-dictionary/blob/main/lib/common/transforms.js)

> All the pre-defined transforms included use the [CTI structure](tokens.md?id=category-type-item) for matching tokens. If you structure your design tokens differently you will need to write [custom transforms](transforms.md?id=defining-custom-transforms) or make sure the proper CTIs are on the attributes of your design tokens.

### attribute/cti 


Adds: category, type, item, subitem, and state on the attributes object based on the location in the style dictionary.

```js
// Matches: all
// Returns:
{
  "category": "color",
  "type": "background",
  "item": "button",
  "subitem": "primary",
  "state": "active"
}
```


* * *

### attribute/color 


Adds: hex, hsl, hsv, rgb, red, blue, green.

```js
// Matches: token.attributes.category === 'color'
// Returns
{
  "hex": "009688",
  "rgb": {"r": 0, "g": 150, "b": 136, "a": 1},
  "hsl": {"h": 174.4, "s": 1, "l": 0.294, "a": 1},
  "hsv": {"h": 174.4, "s": 1, "l": 0.588, "a": 1},
}
```


* * *

### name/human 


Creates a human-friendly name

```js
// Matches: All
// Returns:
"button primary"
```


* * *

### name/cti/camel 


Creates a camel case name. If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"colorBackgroundButtonPrimaryActive"
"prefixColorBackgroundButtonPrimaryActive"
```


* * *

### name/ti/camel 


Creates a camel case name without the category at the front.  This is most useful when there is a class, struct, enum, etc.
that already has the category in it (e.g., StyleDictionaryColors.baseDarkRed instad of StyleDictionaryColors.colorBaseDarkRed).
If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"backgroundButtonPrimaryActive"
"prefixBackgroundButtonPrimaryActive"
```


* * *

### name/cti/kebab 


Creates a kebab case name. If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"color-background-button-primary-active"
"prefix-color-background-button-primary-active"
```


* * *

### name/cti/snake 


Creates a snake case name. If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"color_background_button_primary_active"
"prefix_color_background_button_primary_active"
```


* * *

### name/cti/constant 


Creates a constant-style name based on the full CTI of the token. If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
"PREFIX_COLOR_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
```


* * *

### name/ti/constant 


Creates a constant-style name on the type and item of the token. This is useful if you want to create different static classes/files for categories like `Color.BACKGROUND_BASE`. If you define a prefix on the platform in your config, it will prepend with your prefix.

```js
// Matches: all
// Returns:
"BACKGROUND_BUTTON_PRIMARY_ACTIVE"
"PREFIX_BACKGROUND_BUTTON_PRIMARY_ACTIVE"
```


* * *

### name/cti/pascal 


Creates a Pascal case name. If you define a prefix on the platform in your config, it will prepend with your prefix

```js
// Matches: all
// Returns:
"ColorBackgroundButtonPrimaryActive"
"PrefixColorBackgroundButtonPrimaryActive"
```


* * *

### color/rgb 


Transforms the value into an RGB string

```js
// Matches: token.attributes.category === 'color'
// Returns:
"rgb(0, 150, 136)"
```


* * *

### color/hsl 


Transforms the value into an HSL string or HSLA if alpha is present. Better browser support than color/hsl-4

```js
// Matches: token.attributes.category === 'color'
// Returns:
"hsl(174, 100%, 29%)"
"hsl(174, 100%, 29%, .5)"
```


* * *

### color/hsl-4 


Transforms the value into an HSL string, using fourth argument if alpha is present.

```js
// Matches: token.attributes.category === 'color'
// Returns:
"hsl(174 100% 29%)"
"hsl(174 100% 29% / .5)"
```


* * *

### color/hex 


Transforms the value into an 6-digit hex string

```js
// Matches: token.attributes.category === 'color'
// Returns:
"#009688"
```


* * *

### color/hex8 


Transforms the value into an 8-digit hex string

```js
// Matches: token.attributes.category === 'color'
// Returns:
"#009688ff"
```


* * *

### color/hex8android 


Transforms the value into an 8-digit hex string for Android because they put the alpha channel first

```js
// Matches: token.attributes.category === 'color'
// Returns:
"#ff009688"
```


* * *

### color/composeColor 


Transforms the value into a Color class for Compose

```kotlin
// Matches: prop.attributes.category === 'color'
// Returns:
Color(0xFF009688)
```


* * *

### color/UIColor 


Transforms the value into an UIColor class for iOS

```objectivec
// Matches: token.attributes.category === 'color'
// Returns:
[UIColor colorWithRed:0.114f green:0.114f blue:0.114f alpha:1.000f]
```


* * *

### color/UIColorSwift 


Transforms the value into an UIColor swift class for iOS

```swift
// Matches: token.attributes.category === 'color'
// Returns:
UIColor(red: 0.667, green: 0.667, blue: 0.667, alpha: 0.6)
```


* * *

### color/ColorSwiftUI 


Transforms the value into an UIColor swift class for iOS

```swift
// Matches: token.attributes.category === 'color'
// Returns:
Color(red: 0.667, green: 0.667, blue: 0.667, opacity: 0.6)
```


* * *

### color/css 


Transforms the value into a hex or rgb string depending on if it has transparency

```css
// Matches: token.attributes.category === 'color'
// Returns:
#000000
rgba(0,0,0,0.5)
```


* * *

### color/sketch 


Transforms a color into an object with red, green, blue, and alpha
attributes that are floats from 0 - 1. This object is how Sketch stores
colors.

```js
// Matches: token.attributes.category === 'color'
// Returns:
{
  red: 0.5,
  green: 0.5,
  blue: 0.5,
  alpha: 1
}
```


* * *

### size/sp 


Transforms the value into a scale-independent pixel (sp) value for font sizes on Android. It will not scale the number.

```js
// Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
// Returns:
"10.0sp"
```


* * *

### size/dp 


Transforms the value into a density-independent pixel (dp) value for non-font sizes on Android. It will not scale the number.

```js
// Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
// Returns:
"10.0dp"
```


* * *

### size/object 


Transforms the value into a usefull object ( for React Native support )

```js
// Matches: token.attributes.category === 'size'
// Returns:
{
 original: "10px",
 number: 10,
 decimal: 0.1, // 10 divided by 100
 scale: 160, // 10 times 16
}
```


* * *

### size/remToSp 


Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).

```js
// Matches: token.attributes.category === 'size' && token.attributes.type === 'font'
// Returns:
"16.0sp"
```


* * *

### size/remToDp 


Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes on Android. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).

```js
// Matches: token.attributes.category === 'size' && token.attributes.type !== 'font'
// Returns:
"16.0dp"
```


* * *

### size/px 


Adds 'px' to the end of the number. Does not scale the number

```js
// Matches: token.attributes.category === 'size'
// Returns:
"10px"
```


* * *

### size/rem 


Adds 'rem' to the end of the number. Does not scale the number

```js
// Matches: token.attributes.category === 'size'
// Returns:
"10rem"
```


* * *

### size/remToPt 


Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'pt' to the end.

```js
// Matches: token.attributes.category === 'size'
// Returns:
"16pt"
```


* * *

### size/compose/remToSp 


Transforms the value from a REM size on web into a scale-independent pixel (sp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).

```kotlin
// Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
// Returns:
"16.0.sp"
```


* * *

### size/compose/remToDp 


Transforms the value from a REM size on web into a density-independent pixel (dp) value for font sizes in Compose. It WILL scale the number by a factor of 16 (or the value of 'basePxFontSize' on the platform in your config).

```kotlin
// Matches: prop.attributes.category === 'size' && prop.attributes.type !== 'font'
// Returns:
"16.0.dp"
```


* * *

### size/compose/em 


Adds the .em Compose extension to the end of a number. Does not scale the value

```kotlin
// Matches: prop.attributes.category === 'size' && prop.attributes.type === 'font'
// Returns:
"16.0em"
```


* * *

### size/swift/remToCGFloat 


Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Swift and initializes a CGFloat

```js
// Matches: token.attributes.category === 'size'
// Returns: "CGFloat(16.00)""
```


* * *

### size/remToPx 


Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) and adds 'px' to the end.

```js
// Matches: token.attributes.category === 'size'
// Returns:
"16px"
```


* * *

### content/icon 


Takes a unicode point and transforms it into a form CSS can use.

```js
// Matches: token.attributes.category === 'content' && token.attributes.type === 'icon'
// Returns:
"'\\E001'"
```


* * *

### content/quote 


Wraps the value in a single quoted string

```js
// Matches: token.attributes.category === 'content'
// Returns:
"'string'"
```


* * *

### content/objC/literal 


Wraps the value in a double-quoted string and prepends an '@' to make a string literal.

```objectivec
// Matches: token.attributes.category === 'content'
// Returns:

**&quot;string&quot;**: ```  

* * *

### content/swift/literal 


Wraps the value in a double-quoted string to make a string literal.

```swift
// Matches: token.attributes.category === 'content'
// Returns:
"string"
```


* * *

### font/objC/literal 


Wraps the value in a double-quoted string and prepends an '@' to make a string literal.

```objectivec
// Matches: token.attributes.category === 'font'
// Returns: @"string"
```


* * *

### font/swift/literal 


Wraps the value in a double-quoted string to make a string literal.

```swift
// Matches: token.attributes.category === 'font'
// Returns: "string"
```


* * *

### time/seconds 


Assumes a time in miliseconds and transforms it into a decimal

```js
// Matches: token.attributes.category === 'time'
// Returns:
"0.5s"
```


* * *

### asset/base64 


Wraps the value in a double-quoted string and prepends an '@' to make a string literal.

```js
// Matches: token.attributes.category === 'asset'
// Returns:
'IyBlZGl0b3Jjb25maWcub3JnCnJvb3QgPSB0cnVlCgpbKl0KaW5kZW50X3N0eWxlID0gc3BhY2UKaW5kZW50X3NpemUgPSAyCmVuZF9vZl9saW5lID0gbGYKY2hhcnNldCA9IHV0Zi04CnRyaW1fdHJhaWxpbmdfd2hpdGVzcGFjZSA9IHRydWUKaW5zZXJ0X2ZpbmFsX25ld2xpbmUgPSB0cnVlCgpbKi5tZF0KdHJpbV90cmFpbGluZ193aGl0ZXNwYWNlID0gZmFsc2U='
```


* * *

### asset/path 


Prepends the local file path

```js
// Matches: token.attributes.category === 'asset'
// Returns:
"path/to/file/asset.png"
```


* * *

### asset/objC/literal 


Wraps the value in a double-quoted string and prepends an '@' to make a string literal.

```objectivec
// Matches: token.attributes.category === 'asset'
// Returns: @"string"
```


* * *

### asset/swift/literal 


Wraps the value in a double-quoted string to make a string literal.

```swift
// Matches: token.attributes.category === 'asset'
// Returns: "string"
```


* * *

### color/hex8flutter 


Transforms the value into a Flutter Color object using 8-digit hex with the alpha chanel on start
 ```js
 // Matches: token.attributes.category === 'color'
 // Returns:
 Color(0xFF00FF5F)
 ```


* * *

### content/flutter/literal 


Wraps the value in a double-quoted string to make a string literal.

```dart
// Matches: token.attributes.category === 'content'
// Returns: "string"
```


* * *

### asset/flutter/literal 


Wraps the value in a double-quoted string to make a string literal.

```dart
// Matches: token.attributes.category === 'asset'
// Returns: "string"
```


* * *

### font/flutter/literal 


Wraps the value in a double-quoted string to make a string literal.

```dart
// Matches: token.attributes.category === 'font'
// Returns: "string"
```


* * *

### size/flutter/remToDouble 


Scales the number by 16 (or the value of 'basePxFontSize' on the platform in your config) to get to points for Flutter

```dart
// Matches: token.attributes.category === 'size'
// Returns: 16.00
```


* * *

