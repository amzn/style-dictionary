<!--
DO NOT EDIT THIS FILE DIRECTLY, THIS FILE IS GENERATED BY JSDOC!
EDIT scripts/handlebars/templates/api.hbs OR JSDOC COMMENT INSTEAD!
-->
# Formats

Formats define the output of your created files. For example, to use your styles in CSS
you use the `css/variables` format. This will create a CSS file containing the variables from
your style dictionary.

## Using formats

You use formats in your config file under platforms > [platform] > files > [file] > format

```json
{
  "source": ["tokens/**/*.json"],
  "platforms": {
    "css": {
      "transformGroup": "css",
      "files": [
        {
          "format": "css/variables",
          "destination": "variables.css"
        }
      ]
    }
  }
}
```

There is an extensive (but not exhaustive) list of [included formats](#pre-defined-formats) available in Style Dictionary.

## Format configuration

Formats can take configuration to make them more flexible. This allows you to re-use the same format multiple times with different configurations or to allow the format to use data not defined in the tokens themselves. To configure a format, add extra attributes on the file object in your configuration like the following:

```json
{
  "source": ["tokens/**/*.json"],
  "platforms": {
    "scss": {
      "transformGroup": "scss",
      "files": [{
        "destination": "map.scss",
        "format": "scss/map-deep",
        "mapName": "my-tokens"
      }]
    }
  }
}
```

In this example we are adding the `mapName` configuration to the `scss/map-deep` format. This will change the name of the SCSS map in the output. Not all formats have the configuration options; format configuration is defined by the format itself. To see the configuration options of a format, take a look at the documentation of the [specific format](#pre-defined-formats)

## Filtering tokens

A special file configuration is `filter`, which will filter the tokens before they get to the format. This allows you to re-use the same format to generate multiple files with different sets of tokens. Filtering tokens works by adding a `filter` attribute on the file object, where `filter` is:

* An object which gets passed to [Lodash's filter method](https://lodash.com/docs/4.17.14#filter).
* A string that references the name of a registered filter, using the [`registerFilter`](api.md#registerfilter) method
* A function that takes a token and returns a boolean if the token should be included (true) or excluded (false). **This is only available if you are defining your configuration in Javascript.**

```javascript
{
  "destination": "destination",
  "format": "myCustomFormat",
  "filter": "myCustomFilter", // a named filter defined with .registerFilter
  "filter": function(token) {}, // an inline function
  "filter": {} // an object pass to lodash's filter method
}
```

The design token that is passed to the filter function has already been [transformed](transforms.md) and has [default metadata](tokens.md?id=default-design-token-metadata) added by Style Dictionary.

## References in output files

Starting with version 3.0, some formats can keep the references in the output. This is a bit hard to explain, so let's look at an example. Say you have this very basic set of design tokens:

```json5
// tokens.json
{
  "color": {
    "red": { "value": "#ff0000" },
    "danger": { "value": "{color.red.value}" },
    "error": { "value": "{color.danger.value}" }
  }
}
```

With this configuration:

```json5
// config.json
{
  "source": ["tokens.json"]
  "platforms": {
    "css": {
      "transformGroup": "css",
      "files": [{
        "destination": "variables.css",
        "format": "css/variables",
        "options": {
          // Look here ðŸ‘‡
          "outputReferences": true
        }
      }]
    }
  }
}
```

This would be the output:

```css
:root {
  --color-red: #ff0000;
  --color-danger: var(--color-red);
  --color-error: var(--color-danger);
}
```

The css variables file now keeps the references you have in your Style Dictionary! This is useful for outputting themeable and dynamic code.

Without `outputReferences: true` Style Dictionary would resolve all references and the output would be:

```css
:root {
  --color-red: #ff0000;
  --color-danger: #ff0000;
  --color-error: #ff0000;
}
```

Not all formats use the `outputReferences` option because that file format might not support it (like JSON for example). The current list of formats that handle `outputReferences`:

* [css/variables](#cssvariables)
* [scss/variables](#scssvariables)
* [less/variables](#lessvariables)
* [android/resources](#androidresources)
* [compose/object](#composeobject)
* [ios-swift/class.swift](#ios-swiftclassswift)
* [flutter/class.dart](#flutterclassdart)

You can create custom formats that output references as well. See the [Custom format with output references](#custom-format-with-output-references) section.

## File headers

By default Style Dictionary adds a file header comment in the top of files built using built-in formats like this:

```js
// Do not edit directly
// Generated on Sat, 01 Jan 2000 00:00:00 GMT
```

You can remove these comments with the option: `showFileHeader: false` if you do not want them in your generated files. You can also create your own file header or extend the default one. This could be useful if you want to put a version number or hash of the source files rather than a timestamp.

Custom file headers can be added the same way you would add a custom format, either by using the [`registerFileHeader`](api.md#registerfileheader) function or adding the fileHeader object directly in the Style Dictionary [configuration](config.md). Your custom file header can be used in built-in formats as well as custom formats. To use a custom file header in a custom format see the [`fileHeader`](formats.md#fileheader) format helper method.

```js
const StyleDictionary = require('style-dictionary');
StyleDictionary.registerFileHeader({
  name: 'myCustomHeader',
  fileHeader: (defaultMessage) => {
    // defaultMessage are the 2 lines above that appear in the default file header
    // you can use this to add a message before or after the default message ðŸ‘‡

    // the fileHeader function should return an array of strings
    // which will be formatted in the proper comment style for a given format
    return [
      ...defaultMessage,
      `hello?`,
      `is it me you're looking for?`,
    ]
  }
});
```

Then you can use your custom file header in a file similar to a custom format:

```json5
{
  source: ['tokens/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      files: [{
        destination: 'variables.css',
        format: 'css/variables',
        options: {
          fileHeader: 'myCustomHeader'
        }
      }]
    }
  }
}
```

Which should output a file that will start like this:

```css
/**
 * Do not edit directly
 * Generated on Thu, 18 Mar 2021 21:30:47 GMT
 * hello?
 * is it me you're looking for?
 */
```

For an in-depth example see the [custom-file-header](https://github.com/amzn/style-dictionary/tree/main/examples/advanced/custom-file-header) example.

## Custom formats

You can create custom formats using the [`registerFormat`](api.md#registerformat) function or by directly including them in your [configuration](config.md). A format has a name and a formatter function, which takes an object as the argument and should return a string which is then written to a file.

### formatter 
> format.formatter(args) â‡’ <code>String</code>

The formatter function that is called when Style Dictionary builds files.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>args</td><td><code>Object</code></td><td><p>A single argument to support named parameters and destructuring.</p>
</td>
    </tr><tr>
    <td>args.dictionary</td><td><code>Object</code></td><td><p>The transformed and resolved dictionary object</p>
</td>
    </tr><tr>
    <td>args.dictionary.tokens</td><td><code>Object</code></td><td><p>Object structure of the tokens that has been transformed and references resolved.</p>
</td>
    </tr><tr>
    <td>args.dictionary.allTokens</td><td><code>Array</code></td><td><p>Flattened array of all the tokens. This makes it easy to output a list, like a list of SCSS variables.</p>
</td>
    </tr><tr>
    <td>args.dictionary.usesReference</td><td><code>function</code></td><td><p>Use this function to see if a token&#39;s value uses a reference. This is the same function style dictionary uses internally to detect a reference.</p>
</td>
    </tr><tr>
    <td>args.dictionary.getReferences</td><td><code>function</code></td><td><p>Use this function to get the tokens that it references. You can use this to output a reference in your custom format. For example: <code>dictionary.getReferences(token.original.value) // returns an array of the referenced token objects</code></p>
</td>
    </tr><tr>
    <td>args.platform</td><td><code>Object</code></td><td><p>The platform configuration this format is being called in.</p>
</td>
    </tr><tr>
    <td>args.file</td><td><code>Object</code></td><td><p>The file configuration this format is being called in.</p>
</td>
    </tr><tr>
    <td>args.options</td><td><code>Object</code></td><td><p>Merged options object that combines platform level configuration and file level configuration. File options take precedence.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```js
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({dictionary, platform, options, file}) {
    return JSON.stringify(dictionary.tokens, null, 2);
  }
})
```

* * *


To use your custom format, you call it by name in the file configuration object:

```json
{
  "source": ["tokens/**/*.json"],
  "platforms": {
    "css": {
      "options": {
        "showFileHeader": true
      },
      "transformGroup": "css",
      "files": [{
        "destination": "destination",
        "format": "myCustomFormat",
        "options": {
          "showFileHeader": false
        }
      }]
    }
  }
}
```

It is recommended for any configuration needed for your custom format to use the `options` object. Style Dictionary will merge platform and file options so that in your Style Dictionary configuration you can specify options at a platform or file level. In the configuration above, the `options` object passed to the formatter would have `showFileHeader: false`.

<div class="alert">
Note: to support legacy ways of defining custom formats, <code>this</code> in the formatter function is bound to the file object and when Style Dictionary calls the formatter function it passes 3 arguments: dictionary, platform, and file. Starting in 3.0 all data the formatter needs is in the first argument as shown above to make it easier to grab the arguments by name rather than by position. We recommend not using <code>this</code> or the positional arguments in your custom format.
</div>

## Custom format with output references

To take advantage of outputting references in your custom formats there are 2 helper methods in the `dictionary` argument passed to your formatter function: `usesReference(value)` and `getReferences(value)`. Here is an example using those:

```javascript
StyleDictionary.registerFormat({
  name: `es6WithReferences`,
  formatter: function({dictionary}) {
    return dictionary.allTokens.map(token => {
      let value = JSON.stringify(token.value);
      // the `dictionary` object now has `usesReference()` and
      // `getReferences()` methods. `usesReference()` will return true if
      // the value has a reference in it. `getReferences()` will return
      // an array of references to the whole tokens so that you can access their
      // names or any other attributes.
      if (dictionary.usesReference(token.original.value)) {
        // Note: make sure to use `token.original.value` because
        // `token.value` is already resolved at this point.
        const refs = dictionary.getReferences(token.original.value);
        refs.forEach(ref => {
          value = value.replace(ref.value, function() {
            return `${ref.name}`;
          });
        });
      }
      return `export const ${token.name} = ${value};`
    }).join(`\n`)
  }
});
```

## Custom format helpers

We provide some helper methods we use internally in some of the built-in formats to make building custom formats a bit easier. They are accessible at `StyleDictionary.formatHelpers`.

```javascript
const StyleDictionary = require('style-dictionary');

const { fileHeader, formattedVariables } = StyleDictionary.formatHelpers;

StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({dictionary, file, options}) {
    const { outputReferences } = options;
    return fileHeader({file}) +
      ':root {\n' +
      formattedVariables({format: 'css', dictionary, outputReferences}) +
      '\n}\n';
  }
});
```

Here are the available format helper methods:

### createPropertyFormatter 
> formatHelpers.createPropertyFormatter(options) â‡’ <code>function</code>

Creates a function that can be used to format a property. This can be useful
to use as the function on `dictionary.allTokens.map`. The formatting
is configurable either by supplying a `format` option or a `formatting` object
which uses: prefix, indentation, separator, suffix, and commentStyle.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td>
    </tr><tr>
    <td>options.outputReferences</td><td><code>Boolean</code></td><td><p>Whether or not to output references. You will want to pass this from the <code>options</code> object sent to the formatter function.</p>
</td>
    </tr><tr>
    <td>options.outputReferenceFallbacks</td><td><code>Boolean</code></td><td><p>Whether or not to output css variable fallback values when using output references. You will want to pass this from the <code>options</code> object sent to the formatter function.</p>
</td>
    </tr><tr>
    <td>options.dictionary</td><td><code>Dictionary</code></td><td><p>The dictionary object sent to the formatter function</p>
</td>
    </tr><tr>
    <td>options.format</td><td><code>String</code></td><td><p>Available formats are: &#39;css&#39;, &#39;sass&#39;, &#39;less&#39;, and &#39;stylus&#39;. If you want to customize the format and can&#39;t use one of those predefined formats, use the <code>formatting</code> option</p>
</td>
    </tr><tr>
    <td>options.formatting</td><td><code>Object</code></td><td><p>Custom formatting properties that define parts of a declaration line in code. The configurable strings are: prefix, indentation, separator, suffix, and commentStyle. Those are used to generate a line like this: <code>${indentation}${prefix}${prop.name}${separator} ${prop.value}${suffix}</code></p>
</td>
    </tr><tr>
    <td>options.themeable</td><td><code>Boolean</code></td><td><p>[false] - Whether tokens should default to being themeable.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```javascript
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, options }) {
    const { outputReferences } = options;
    const formatProperty = createPropertyFormatter({
      outputReferences,
      dictionary,
      format: 'css'
    });
    return dictionary.allTokens.map(formatProperty).join('\n');
  }
});
```

* * *

### fileHeader 
> formatHelpers.fileHeader(options) â‡’ <code>String</code>

This is for creating the comment at the top of generated files with the generated at date.
It will use the custom file header if defined on the configuration, or use the
default file header.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td>
    </tr><tr>
    <td>options.file</td><td><code>File</code></td><td><p>The file object that is passed to the formatter.</p>
</td>
    </tr><tr>
    <td>options.commentStyle</td><td><code>String</code></td><td><p>The only options are &#39;short&#39; and &#39;xml&#39;, which will use the // or &lt;!-- --&gt; style comments respectively. Anything else will use /* style comments.</p>
</td>
    </tr><tr>
    <td>options.formatting</td><td><code>Object</code></td><td><p>Custom formatting properties that define parts of a comment in code. The configurable strings are: prefix, lineSeparator, header, and footer.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```js
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, file }) {
    return fileHeader({file, commentStyle: 'short'}) +
      dictionary.allTokens.map(token => `${token.name} = ${token.value}`)
        .join('\n');
  }
});
```

* * *

### formattedVariables 
> formatHelpers.formattedVariables(options) â‡’ <code>String</code>

This is used to create lists of variables like Sass variables or CSS custom properties

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td>
    </tr><tr>
    <td>options.format</td><td><code>String</code></td><td><p>What type of variables to output. Options are: css, sass, less, and stylus</p>
</td>
    </tr><tr>
    <td>options.dictionary</td><td><code>Object</code></td><td><p>The dictionary object that gets passed to the formatter method.</p>
</td>
    </tr><tr>
    <td>options.outputReferences</td><td><code>Boolean</code></td><td><p>Whether or not to output references</p>
</td>
    </tr><tr>
    <td>options.formatting</td><td><code>Object</code></td><td><p>Custom formatting properties that define parts of a declaration line in code. This will get passed to <code>formatHelpers.createPropertyFormatter</code> and used for the <code>lineSeparator</code> between lines of code.</p>
</td>
    </tr><tr>
    <td>options.themeable</td><td><code>Boolean</code></td><td><p>[false] - Whether tokens should default to being themeable.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```js
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, options }) {
    return formattedVariables({
      format: 'less',
      dictionary,
      outputReferences: options.outputReferences
    });
  }
});
```

* * *

### getTypeScriptType 
> formatHelpers.getTypeScriptType(value, options) â‡’ <code>String</code>

Given some value, returns a basic valid TypeScript type for that value.
Supports numbers, strings, booleans, arrays and objects of any of those types.

**Returns**: <code>String</code> - A valid name for a TypeScript type.  
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>value</td><td><code>*</code></td><td><p>A value to check the type of.</p>
</td>
    </tr><tr>
    <td>options</td><td><code>Object</code></td><td></td>
    </tr><tr>
    <td>options.outputStringLiterals</td><td><code>Boolean</code></td><td><p>Whether or not to output literal types for string values</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```javascript
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, options }) {
   return dictionary.allProperties.map(function(prop) {
     var to_ret_prop = 'export const ' + prop.name + ' : ' + getTypeScriptType(prop.value) + ';';
     if (prop.comment)
       to_ret_prop = to_ret_prop.concat(' // ' + prop.comment);
     return to_ret_prop;
   }).join('\n');
  }
});
```

* * *

### iconsWithPrefix 
> formatHelpers.iconsWithPrefix(prefix, allTokens, options) â‡’ <code>String</code>

This is used to create CSS (and CSS pre-processor) lists of icons. It assumes you are
using an icon font and creates helper classes with the :before pseudo-selector to add
a unicode character.
__You probably don't need this.__

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>prefix</td><td><code>String</code></td><td><p>Character to prefix variable names, like &#39;$&#39; for Sass</p>
</td>
    </tr><tr>
    <td>allTokens</td><td><code>Array.&lt;Token&gt;</code></td><td><p>allTokens array on the dictionary object passed to the formatter function.</p>
</td>
    </tr><tr>
    <td>options</td><td><code>Object</code></td><td><p>options object passed to the formatter function.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```js
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, options }) {
    return iconsWithPrefix('$', dictionary.allTokens, options);
  }
});
```

* * *

### minifyDictionary 
> formatHelpers.minifyDictionary(obj) â‡’ <code>Object</code>

Outputs an object stripping out everything except values

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>obj</td><td><code>Object</code></td><td><p>The object to minify. You will most likely pass <code>dictionary.tokens</code> to it.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```js
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary }) {
    return JSON.stringify(minifyDictionary(dictionary.tokens));
  }
});
```

* * *

### setComposeObjectProperties 
> formatHelpers.setComposeObjectProperties(options) â‡’ <code>Object</code>

Outputs an object for compose format configurations. Sets import.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td><p>The options object declared at configuration</p>
</td>
    </tr>  </tbody>
</table>


* * *

### setSwiftFileProperties 
> formatHelpers.setSwiftFileProperties(options, objectType, transformGroup) â‡’ <code>Object</code>

Outputs an object with swift format configurations. Sets import, object type and access control.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td><p>The options object declared at configuration</p>
</td>
    </tr><tr>
    <td>objectType</td><td><code>String</code></td><td><p>The type of the object in the final file. Could be a class, enum, struct, etc.</p>
</td>
    </tr><tr>
    <td>transformGroup</td><td><code>String</code></td><td><p>The transformGroup of the file, so it can be applied proper import</p>
</td>
    </tr>  </tbody>
</table>


* * *

### sortByName 
> formatHelpers.sortByName(a, b) â‡’ <code>Integer</code>

A sorting function to be used when iterating over `dictionary.allTokens` in
a format.

**Returns**: <code>Integer</code> - -1 or 1 depending on which element should come first based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort  
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>a</td><td><code>*</code></td><td><p>first element for comparison</p>
</td>
    </tr><tr>
    <td>b</td><td><code>*</code></td><td><p>second element for comparison</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```javascript
StyleDictionary.registerFormat({
  name: 'myCustomFormat',
  formatter: function({ dictionary, options }) {
    return dictionary.allTokens.sort(sortByName)
      .map(token => `${token.name} = ${token.value}`)
      .join('\n');
  }
});
```

* * *

### sortByReference 
> formatHelpers.sortByReference(dictionary) â‡’ <code>function</code>

A function that returns a sorting function to be used with Array.sort that
will sort the allTokens array based on references. This is to make sure
if you use output references that you never use a reference before it is
defined.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>dictionary</td><td><code>Dictionary</code></td>
    </tr>  </tbody>
</table>

**Example**  
```javascript
dictionary.allTokens.sort(sortByReference(dictionary))
```

* * *


## Using a template / templating engine to create a format

Formatters are functions and created easily with most templating engines. Formats can be built using templates if there is a lot of boilerplate code to insert (e.g. ObjectiveC files). If the output consists of only the values (e.g. a flat SCSS variables file), writing a formatter function directly may be easier.

Any templating language can work as long as there is a node module for it. All you need to do is register a format that calls your template and returns a string.

Here is a quick example for Lodash.

```js
const styleDictionary = require('style-dictionary').extend('config.json');
const _ = require('lodash');

const template = _.template( fs.readFileSync('templates/myFormat.template') );

styleDictionary.registerFormat({
  name: 'my/format',
  formatter: template
});

// format: 'my/format' is now available for use...
```

And another example for Handlebars.

```js
const styleDictionary = require('style-dictionary').extend('config.json');
const Handlebars = require('handlebars');

const template = Handlebars.compile( fs.readFileSync('templates/MyTemplate.hbs').toString() );

styleDictionary.registerFormat({
  name: 'my/format',
  formatter: function({dictionary, platform}) {
    return template({
      tokens: dictionary.tokens,
      options: platform
    });
  }
});

// format: 'my/format' is now available for use...
```

----

## Pre-defined Formats

These are the formats included in Style Dictionary by default, pulled from [lib/common/formats.js](https://github.com/amzn/style-dictionary/blob/main/lib/common/formats.js)

Want a format? [You can request it here](https://github.com/amzn/style-dictionary/issues).

You created a format and think it should be included? [Send us a PR](https://github.com/amzn/style-dictionary/pulls).


### css/variables 


Creates a CSS file with variable definitions based on the style dictionary

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr><tr>
    <td>[options.selector]</td><td><code>string</code></td><td></td><td><p>Override the root css selector</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```css
:root {
  --color-background-base: #f0f0f0;
  --color-background-alt: #eeeeee;
}
```

* * *

### scss/map-flat 


Creates a SCSS file with a flat map based on the style dictionary

Name the map by adding a 'mapName' attribute on the file object in your config.

**Example**  
```scss
$tokens: (
  'color-background-base': #f0f0f0;
  'color-background-alt': #eeeeee;
)
```

* * *

### scss/map-deep 


Creates a SCSS file with a deep map based on the style dictionary.

Name the map by adding a 'mapName' attribute on the file object in your config.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr><tr>
    <td>[options.themeable]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not tokens should default to being themeable, if not otherwise specified per token.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```scss
$color-background-base: #f0f0f0 !default;
$color-background-alt: #eeeeee !default;

$tokens: {
  'color': (
    'background': (
      'base': $color-background-base,
      'alt': $color-background-alt
    )
  )
)
```

* * *

### scss/variables 


Creates a SCSS file with variable definitions based on the style dictionary.

Add `!default` to any variable by setting a `themeable: true` attribute in the token's definition.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr><tr>
    <td>[options.themeable]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not tokens should default to being themeable, if not otherwise specified per token.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```scss
$color-background-base: #f0f0f0;
$color-background-alt: #eeeeee !default;
```

* * *

### scss/icons 


Creates a SCSS file with variable definitions and helper classes for icons

**Example**  
```scss
$content-icon-email: '\E001';
.icon.email:before { content:$content-icon-email; }
```

* * *

### less/variables 


Creates a LESS file with variable definitions based on the style dictionary

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```less
@color-background-base: #f0f0f0;
@color-background-alt: #eeeeee;
```

* * *

### less/icons 


Creates a LESS file with variable definitions and helper classes for icons

**Example**  
```less
@content-icon-email: '\E001';
.icon.email:before { content:@content-icon-email; }
```

* * *

### stylus/variables 


Creates a Stylus file with variable definitions based on the style dictionary

**Example**  
```stylus
$color-background-base= #f0f0f0;
$color-background-alt= #eeeeee;
```

* * *

### javascript/module 


Creates a CommonJS module with the whole style dictionary

**Example**  
```js
module.exports = {
  color: {
    base: {
       red: {
         value: '#ff0000'
       }
    }
  }
}
```

* * *

### javascript/module-flat 


Creates a CommonJS module with the whole style dictionary flattened to a single level.

**Example**  
```js
module.exports = {
 "ColorBaseRed": "#ff0000"
}
```

* * *

### javascript/object 


Creates a JS file a global var that is a plain javascript object of the style dictionary.
Name the variable by adding a 'name' attribute on the file object in your config.

**Example**  
```js
var StyleDictionary = {
  color: {
    base: {
       red: {
         value: '#ff0000'
       }
    }
  }
}
```

* * *

### javascript/umd 


Creates a [UMD](https://github.com/umdjs/umd) module of the style
dictionary. Name the module by adding a 'name' attribute on the file object
in your config.

**Example**  
```js
(function(root, factory) {
  if (typeof module === "object" && module.exports) {
    module.exports = factory();
  } else if (typeof exports === "object") {
    exports["_styleDictionary"] = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root["_styleDictionary"] = factory();
  }
}(this, function() {
  return {
    "color": {
      "red": {
        "value": "#FF0000"
      }
    }
  };
}))
```

* * *

### javascript/es6 


Creates a ES6 module of the style dictionary.

```json
{
  "platforms": {
    "js": {
      "transformGroup": "js",
      "files": [
        {
          "format": "javascript/es6",
          "destination": "colors.js",
          "filter": {
            "attributes": {
              "category": "color"
            }
          }
        }
      ]
    }
  }
}
```

**Example**  
```js
export const ColorBackgroundBase = '#ffffff';
export const ColorBackgroundAlt = '#fcfcfcfc';
```

* * *

### typescript/es6-declarations 


Creates TypeScript declarations for ES6 modules

```json
{
  "platforms": {
    "ts": {
      "transformGroup": "js",
      "files": [
        {
          "format": "javascript/es6",
          "destination": "colors.js"
        },
        {
          "format": "typescript/es6-declarations",
          "destination": "colors.d.ts"
        }
      ]
    }
  }
}
```

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.outputStringLiterals]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to output literal types for string values</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```typescript
export const ColorBackgroundBase : string;
export const ColorBackgroundAlt : string;
```

* * *

### typescript/module-declarations 


Creates TypeScript declarations for CommonJS module

```json
{
  "platforms": {
    "ts": {
      "transformGroup": "js",
      "files": [
        {
          "format": "javascript/module",
          "destination": "colors.js"
        },
        {
          "format": "typescript/module-declarations",
          "destination": "colors.d.ts"
        }
      ]
    }
  }
}
```

**Example**  
```typescript
export default tokens;
declare interface DesignToken { value: string; name?: string; path?: string[]; comment?: string; attributes?: any; original?: any; }
declare const tokens: {
 "color": {
   "red": DesignToken
 }
}
```

As you can see above example output this does not generate 100% accurate d.ts.
This is a compromise between of what style-dictionary can do to help and not bloating the library with rarely used dependencies.

Thankfully you can extend style-dictionary very easily:

```js
const JsonToTS = require('json-to-ts');
StyleDictionaryPackage.registerFormat({
  name: 'typescript/accurate-module-declarations',
  formatter: function({ dictionary }) {
    return 'declare const root: RootObject\n' +
    'export default root\n' +
    JsonToTS(dictionary.properties).join('\n');
  },
});
```

* * *

### android/resources 


Creates a [resource](https://developer.android.com/guide/topics/resources/providing-resources) xml file. It is recommended to use a filter with this format
as it is generally best practice in Android development to have resource files
organized by type (color, dimension, string, etc.). However, a resource file
with mixed resources will still work.

This format will try to use the proper resource type for each token based on
the category (color => color, size => dimen, etc.). However if you want to
force a particular resource type you can provide a 'resourceType' attribute
on the file configuration. You can also provide a 'resourceMap' if you
don't use Style Dictionary's built-in CTI structure.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
 <color name="color_base_red_5">#fffaf3f2</color>
 <color name="color_base_red_30">#fff0cccc</color>
 <dimen name="size_font_base">14sp</color>
```

* * *

### android/colors 


Creates a color resource xml file with all the colors in your style dictionary.

It is recommended to use the 'android/resources' format with a custom filter
instead of this format:

```javascript
format: 'android/resources',
filter: {
  attributes: { category: 'color' }
}
```

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
 <color name="color_base_red_5">#fffaf3f2</color>
 <color name="color_base_red_30">#fff0cccc</color>
 <color name="color_base_red_60">#ffe19d9c</color>
```

* * *

### android/dimens 


Creates a dimen resource xml file with all the sizes in your style dictionary.

It is recommended to use the 'android/resources' format with a custom filter
instead of this format:

```javascript
format: 'android/resources',
filter: {
  attributes: { category: 'size' }
}
```

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
 <dimen name="size_padding_tiny">5.00dp</dimen>
 <dimen name="size_padding_small">10.00dp</dimen>
 <dimen name="size_padding_medium">15.00dp</dimen>
```

* * *

### android/fontDimens 


Creates a dimen resource xml file with all the font sizes in your style dictionary.

It is recommended to use the 'android/resources' format with a custom filter
instead of this format:

```javascript
format: 'android/resources',
filter: {
  attributes: { category: 'size' }
}
```

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
 <dimen name="size_font_tiny">10.00sp</dimen>
 <dimen name="size_font_small">13.00sp</dimen>
 <dimen name="size_font_medium">15.00sp</dimen>
```

* * *

### android/integers 


Creates a resource xml file with all the integers in your style dictionary. It filters your
design tokens by `token.attributes.category === 'time'`

It is recommended to use the 'android/resources' format with a custom filter
instead of this format:

```javascript
format: 'android/resources',
filter: {
  attributes: { category: 'time' }
}
```

**Todo**

- Update the filter on this.

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
  <integer name="time_duration_short">1000</integer>
  <integer name="time_duration_medium">2000</integer>
  <integer name="time_duration_long">4000</integer>
```

* * *

### android/strings 


Creates a resource xml file with all the strings in your style dictionary. Filters your
design tokens by `token.attributes.category === 'content'`

It is recommended to use the 'android/resources' format with a custom filter
instead of this format:

```javascript
format: 'android/resources',
filter: {
  attributes: { category: 'content' }
}
```

**Example**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<resources>
  <string name="content_icon_email">&#xE001;</string>
  <string name="content_icon_chevron_down">&#xE002;</string>
  <string name="content_icon_chevron_up">&#xE003;</string>
```

* * *

### compose/object 


Creates a Kotlin file for Compose containing an object with a `val` for each property.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>className</td><td><code>String</code></td><td></td><td><p>The name of the generated Kotlin object</p>
</td>
    </tr><tr>
    <td>packageName</td><td><code>String</code></td><td></td><td><p>The package for the generated Kotlin object</p>
</td>
    </tr><tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.import]</td><td><code>Array.&lt;String&gt;</code></td><td><code>[&#x27;androidx.compose.ui.graphics.Color&#x27;, &#x27;androidx.compose.ui.unit.*&#x27;]</code></td><td><p>Modules to import. Can be a string or array of strings</p>
</td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```kotlin
package com.example.tokens;

import androidx.compose.ui.graphics.Color

object StyleDictionary {
 val colorBaseRed5 = Color(0xFFFAF3F2)
}
```

* * *

### ios/macros 


Creates an Objective-C header file with macros for design tokens

**Example**  
```objectivec
#import <Foundation/Foundation.h>
#import <UIKit/UIKit.h>

#define ColorFontLink [UIColor colorWithRed:0.00f green:0.47f blue:0.80f alpha:1.00f]
#define SizeFontTiny 176.00f
```

* * *

### ios/plist 


Creates an Objective-C plist file

**Todo**

- Fix this template and add example and usage


* * *

### ios/singleton.m 


Creates an Objective-C implementation file of a style dictionary singleton class

**Todo**

- Add example and usage


* * *

### ios/singleton.h 


Creates an Objective-C header file of a style dictionary singleton class

**Todo**

- Add example and usage


* * *

### ios/static.h 


Creates an Objective-C header file of a static style dictionary class

**Todo**

- Add example and usage


* * *

### ios/static.m 


Creates an Objective-C implementation file of a static style dictionary class

**Todo**

- Add example and usage


* * *

### ios/colors.h 


Creates an Objective-C header file of a color class

**Todo**

- Add example and usage


* * *

### ios/colors.m 


Creates an Objective-C implementation file of a color class

**Todo**

- Add example and usage


* * *

### ios/strings.h 


Creates an Objective-C header file of strings

**Todo**

- Add example and usage


* * *

### ios/strings.m 


Creates an Objective-C implementation file of strings

**Todo**

- Add example and usage


* * *

### ios-swift/class.swift 


Creates a Swift implementation file of a class with values. It adds default `class` object type, `public` access control and `UIKit` import.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.accessControl]</td><td><code>String</code></td><td><code>public</code></td><td><p>Level of <a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">access</a> of the generated swift object</p>
</td>
    </tr><tr>
    <td>[options.import]</td><td><code>Array.&lt;String&gt;</code></td><td><code>UIKit</code></td><td><p>Modules to import. Can be a string or array of strings</p>
</td>
    </tr><tr>
    <td>[options.className]</td><td><code>String</code></td><td></td><td><p>The name of the generated Swift class</p>
</td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```swift
public class StyleDictionary {
  public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
}
```

* * *

### ios-swift/enum.swift 


Creates a Swift implementation file of an enum with values. It adds default `enum` object type, `public` access control and `UIKit` import.

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.accessControl]</td><td><code>String</code></td><td><code>public</code></td><td><p>Level of <a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">access</a> of the generated swift object</p>
</td>
    </tr><tr>
    <td>[options.import]</td><td><code>Array.&lt;String&gt;</code></td><td><code>UIKit</code></td><td><p>Modules to import. Can be a string or array of strings</p>
</td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```swift
public enum StyleDictionary {
  public static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
}
```

* * *

### ios-swift/any.swift 


Creates a Swift implementation file of any given type with values. It has by default `class` object type, `public` access control and `UIKit` import.

```javascript
format: 'ios-swift/any.swift',
import: ['UIKit', 'AnotherModule'],
objectType: 'struct',
accessControl: 'internal',
```

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.accessControl]</td><td><code>String</code></td><td><code>public</code></td><td><p>Level of <a href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html">access</a> of the generated swift object</p>
</td>
    </tr><tr>
    <td>[options.import]</td><td><code>Array.&lt;String&gt;</code></td><td><code>UIKit</code></td><td><p>Modules to import. Can be a string or array of strings</p>
</td>
    </tr><tr>
    <td>[options.objectType]</td><td><code>String</code></td><td><code>class</code></td><td><p>The type of the generated Swift object</p>
</td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```swift
import UIKit
import AnotherModule

internal struct StyleDictionary {
  internal static let colorBackgroundDanger = UIColor(red: 1.000, green: 0.918, blue: 0.914, alpha: 1)
}
```

* * *

### css/fonts.css 


Creates CSS file with @font-face declarations

**Todo**

- Add example and usage


* * *

### json 


Creates a JSON file of the style dictionary.

**Example**  
```json
{
  "color": {
    "base": {
       "red": {
         "value": "#ff0000"
       }
    }
  }
}
```

* * *

### json/asset 


Creates a JSON file of the assets defined in the style dictionary.

**Example**  
```js
{
  "asset": {
    "image": {
       "logo": {
         "value": "assets/logo.png"
       }
    }
  }
}
```

* * *

### json/nested 


Creates a JSON nested file of the style dictionary.

**Example**  
```json
{
  "color": {
    "base": {
       "red": "#ff0000"
    }
  }
}
```

* * *

### json/flat 


Creates a JSON flat file of the style dictionary.

**Example**  
```json
{
  "color-base-red": "#ff0000"
}
```

* * *

### sketch/palette 


Creates a sketchpalette file of all the base colors

**Example**  
```json
{
  "compatibleVersion": "1.0",
  "pluginVersion": "1.1",
  "colors": [
    "#ffffff",
    "#ff0000",
    "#fcfcfc"
  ]
}
```

* * *

### sketch/palette/v2 


Creates a sketchpalette file compatible with version 2 of
the sketchpalette plugin. To use this you should use the
'color/sketch' transform to get the correct value for the colors.

**Example**  
```json
{
  "compatibleVersion": "2.0",
  "pluginVersion": "2.2",
  "colors": [
    {name: "red", r: 1.0, g: 0.0, b: 0.0, a: 1.0},
    {name: "green", r: 0.0, g: 1.0, b: 0.0, a: 1.0},
    {name: "blue", r: 0.0, g: 0.0, b: 1.0, a: 1.0}
  ]
}
```

* * *

### flutter/class.dart 


Creates a Dart implementation file of a class with values

<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>options</td><td><code>Object</code></td><td></td><td></td>
    </tr><tr>
    <td>[options.showFileHeader]</td><td><code>Boolean</code></td><td><code>true</code></td><td><p>Whether or not to include a comment that has the build date</p>
</td>
    </tr><tr>
    <td>[options.outputReferences]</td><td><code>Boolean</code></td><td><code>false</code></td><td><p>Whether or not to keep <a href="/#/formats?id=references-in-output-files">references</a> (a -&gt; b -&gt; c) in the output.</p>
</td>
    </tr>  </tbody>
</table>

**Example**  
```dart
import 'package:flutter/material.dart';

class StyleDictionary {
  StyleDictionary._();

    static const colorBrandPrimary = Color(0x00ff5fff);
    static const sizeFontSizeMedium = 16.00;
    static const contentFontFamily1 = "NewJune";
```

* * *


