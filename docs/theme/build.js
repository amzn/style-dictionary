import StyleDictionary from 'style-dictionary';
import Color from 'colorjs.io';
import { lightTokens } from './tokens/light.js';
import { darkTokens } from './tokens/dark.js';

const sd = new StyleDictionary({
  log: {
    verbosity: 'verbose',
  },
  hooks: {
    transforms: {
      color: {
        type: 'value',
        transitive: true,
        filter: (token) => {
          return token.$type === 'color';
        },
        transform: (token) => {
          const color = new Color(token.$value);
          return color.to('srgb').toString({ format: 'hex', collapse: false });
        },
      },
      vsCodeName: {
        type: 'name',
        transform: (token) => {
          // syntax tokens we remove the first part of the object path
          if (token.path[0] === 'syntax') {
            // This allows you to have tokens at multiple levels
            // like `comment` and `comment.line`
            if (token.name === '*') {
              // removes the first and last parts of the path
              return token.path.slice(1, -1).join('.');
            } else {
              // removes the first part of the path which would be 'syntax'
              return token.path.slice(1).join('.');
            }
          } else {
            // Used for application colors
            return token.path.join('.');
          }
        },
      },
    },
    formats: {
      monaco: ({ dictionary, platform }) => {
        const theme = {
          base: platform.themeType === 'dark' ? 'vs-dark' : 'vs',
          inherit: true,
          rules: [],
          colors: {},
        };
        // Filter out the design tokens we don't want to add to the
        dictionary.allTokens
          .filter((token) => {
            return !['color', 'syntax'].includes(token.path[0]);
          })
          .forEach((token) => {
            // Add each token to the colors object, the name is generated by the custom
            // transform defined above
            theme.colors[token.name] = token.$value;
          });

        // Map the syntax styles
        theme.rules = dictionary.allTokens
          .filter((token) => {
            return token.path[0] === 'syntax';
          })
          .map((token) => ({
            token: token.name,
            foreground: token.$value,
            fontStyle: token.fontStyle,
          }));

        // Style Dictionary formats expect a string that will be then written to a file
        return JSON.stringify(theme, null, 2);
      },
      vsCodeTheme: ({ dictionary, platform }) => {
        // VSCode theme JSON files have this structure
        const theme = {
          name: `Style Dictionary ${platform.themeType}`,
          type: platform.themeType,
          colors: {},
        };

        // Filter out the design tokens we don't want to add to the
        // 'colors' object. This includes core colors defined in tokens/core.json5
        // and syntax tokens defined in tokens/syntax
        dictionary.allTokens
          .filter((token) => {
            return !['color', 'syntax', 'lch', 'hue', 'lightness', 'chroma'].includes(
              token.path[0],
            );
          })
          .forEach((token) => {
            // Add each token to the colors object, the name is generated by the custom
            // transform defined above
            theme.colors[token.name] = token.$value;
          });

        // Map the syntax styles
        theme.tokenColors = dictionary.allTokens
          .filter((token) => {
            return token.path[0] === 'syntax';
          })
          .map((token) => ({
            scope: token.name,
            settings: {
              foreground: token.$value,
              fontStyle: token.fontStyle,
            },
          }));

        // Style Dictionary formats expect a string that will be then written to a file
        return JSON.stringify(theme, null, 2);
      },
    },
  },
});

// wrapper async function for putting stuff in sequence
const runSD = async (mode) => {
  const sdExt = await sd.extend({
    tokens: mode === 'light' ? lightTokens : darkTokens,

    platforms: {
      vscode: {
        // Directory to build files to
        buildPath: `docs/theme/dist/`,
        // Adding a custom attribute on the platform so we can use it in
        // the custom format
        themeType: mode,
        // The name of the custom transform we defined above
        transforms: [`color`, `vsCodeName`],
        files: [
          {
            // The path the file will be created at. Make sure this matches
            // the file paths defined in the package.json
            destination: `${mode}.vscode.json`,
            // The name of the custom format defined above
            format: `vsCodeTheme`,
          },
          {
            // The path the file will be created at. Make sure this matches
            // the file paths defined in the package.json
            destination: `${mode}.monaco.json`,
            // The name of the custom format defined above
            format: `monaco`,
          },
        ],
      },
      css: {
        buildPath: `docs/theme/dist/`,
        transforms: ['attribute/cti', 'name/kebab'],
        prefix: 'sl',
        files: [
          {
            destination: `${mode}.variables.css`,
            format: 'css/variables',
            // filter: (token) => {
            //   if (token.path[0] === 'lch') {
            //     return true;
            //   }
            //   // light mode don't include the core colors
            //   // because default is dark mode which will have the core colors
            //   if (mode === 'light') {
            //     return token.path[0] === 'color' && token.path[1] !== 'core';
            //   } else {
            //     return token.path[0] === 'color' || token.path[0] === 'lch';
            //   }
            // },
            options: {
              selector:
                mode === 'light' ? `:root[data-theme='light']` : `:root, :root[data-theme='dark']`,
              outputReferences: true,
            },
          },
        ],
      },
    },
  });
  await sdExt.buildAllPlatforms();
};

// to run stuff in parallel
await Promise.all(['dark', 'light'].map(runSD));
